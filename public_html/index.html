<!DOCTYPE html>
<html>
    <head>

        <!--Link to the style sheet file /-->
        <link rel="stylesheet" type="text/css" href="CSS/index.css">

        <title>Peach Pipe Puzzle</title>

        <script>
            
            
            //animation variables
            var xMin = 0;
            //var xMax = $(window).height() - ball.height();
            var xMax = 1000;
            var pos = 0;
            var dir = 1;
            var speed = 8;
            var fps = 60;
            var interval = 1000 / fps;
            
            
            

            // Color for when hovering over a square (NOT NECESSERY)
            const PUZZLE_HOVER_TINT = '#009900';
            // Sets the number of rows and columns
            var _pipegrid_rows = 6;
            var _pipegrid_cols = 6;

            var _stage;
            var _canvas;

            var _test_degrees = 90;


            var _img;
            var _puzzleWidth;
            var _puzzleHeight;

            var _previouspipe_index;
            //Need to remove these two variables, as they're now contained in the 
            //pipe object.
            var _pipeWidth;
            var _pipeHeight;

            var _currentPipe;
            var _currentDropPipe;

            var _mouse;

            var PipesStack = [];
            var RedoStack = [];

            //Pipe class
            function Pipe() {
                this.orientation = 0;
                this.xPos = 0;
                this.yPos = 0;
                this.width = 0;
                this.height = 0;
                this.openLeft = false;
                this.openUp = false;
                this.openRight = false;
                this.openDown = false;
                this.transparency = 1;
                this.image = null;

                this.connectedToA = false;
                this.connectedToB = false;
            }

            //array to store the pipe struct in
            var _pipe_grid = [];

            // Set the straight and bent pipe images up, so they can be referenced
            // by the pipe objects 
            function init() {
                _img_splash = new Image();
                _img_splash.addEventListener('load', onImage, false);
                _img_splash.src = "SplashScreen.png";

                _img_straight = new Image();
                _img_straight.addEventListener('load', onImage, false);
                _img_straight.src = "straightpipe-01.png";

                _img_bent = new Image();
                _img_bent.addEventListener('load', onImage, false);
                _img_bent.src = "bentpipe-01.png";
            }

            // Set the width and height for each pipe, dependant on the number of pipes
            function onImage(e) {
                _pipeWidth = Math.floor(_img_straight.width);
                _pipeHeight = Math.floor(_img_straight.height);
                _puzzleWidth = _pipeWidth * _pipegrid_cols;
                _puzzleHeight = _pipeHeight * _pipegrid_rows;
                setCanvas();
                initGrid();
            }

            // Set Canvas
            function setCanvas() {
                _canvas = document.getElementById('canvas');
                _stage = _canvas.getContext('2d');
                _canvas.width = _puzzleWidth;
                _canvas.height = _puzzleHeight;
                _canvas.style.border = "1px solid black";
                //_canvas.offsetTop = 200;
            }

            // Init variables for the pipe puzzle (before the pipes are randomized)
            function initGrid() {
                //_pipe_grid = [];
                _mouse = {x: 0, y: 0};
                _currentpipe = null;
                _currentDroppipe = null;
                //Draw a start up image :)
                _stage.drawImage(_img_splash, 0, 0, _puzzleWidth, _puzzleHeight, 0, 100, _puzzleWidth, _puzzleHeight);
                createTitle("Double click to start game!!");
                document.onmousedown = buildGrid;
            }

            //Create a fillable rectangle, place text inside of it.
            function createTitle(msg) {
                //Create a fillable rectangle, params: fillRect(x, y, width, height). 
                //Where x and y are the coordinates of the upper left corners position.
                _stage.fillStyle = "#000000";
                _stage.globalAlpha = .4;
                _stage.fillRect(100, _puzzleHeight - 40, _puzzleWidth - 200, 40);
                _stage.fillStyle = "#FFFFFF";
                _stage.globalAlpha = 1;

                //Place a message inside of the fillable rectangle. 
                _stage.textAlign = "center";
                _stage.textBaseline = "middle";
                _stage.font = "20px Arial";
                _stage.fillText(msg, _puzzleWidth / 2, _puzzleHeight - 20);
            }

            //Init an array of all of the pipe puzzle pipes. 
            function buildGrid() {
                var i;
                var xPosition = 0;
                var yPosition = 0;
                for (i = 0; i < _pipegrid_cols * _pipegrid_rows; i++) {

                    //Create a new pipe object
                    var newPipe = new Pipe();
                    newPipe.xPos = xPosition;
                    newPipe.yPos = yPosition;

                    //Randomize between bent and straight pipes  
                    if (Math.random() < 0.5) {
                        if (newPipe.image === null)
                            newPipe.image = _img_straight;
                        newPipe.openLeft = true;
                        newPipe.openUp = false;
                        newPipe.openRight = true;
                        newPipe.openDown = false;
                    }
                    else {
                        if (newPipe.image === null)
                            newPipe.image = _img_bent;
                        newPipe.openLeft = true;
                        newPipe.openUp = false;
                        newPipe.openRight = false;
                        newPipe.openDown = true;
                    }

                    //Push pipe structure into the pipe grid array!
                    _pipe_grid.push(newPipe);

                    //Update the position ready for the placement of next pipe:
                    xPosition += _pipeWidth;
                    if (xPosition >= _puzzleWidth) {
                        xPosition = 0;
                        yPosition += _pipeHeight;
                    }
                }
                //Set the mouse down command to call the ShufflePuzzle method
                document.onmousedown = drawPuzzle;
            }

            //Shuffle the array, clear the stage, replace the pieces. 
            function drawPuzzle() {
                //_pipe_grid = shuffleArray(_pipe_grid);
                _stage.clearRect(0, 0, _puzzleWidth, _puzzleHeight);
                var i;
                var pipe;
                for (i = 0; i < _pipe_grid.length; i++) {
                    pipe = _pipe_grid[i];

                    _stage.drawImage(pipe.image, pipe.xPos, pipe.yPos, _pipeWidth, _pipeHeight);
                    _stage.strokeRect(pipe.xPos, pipe.yPos, _pipeWidth, _pipeHeight);
                }
                //Set the mouse down command to call the onPuzzleClick method
                document.onmousedown = onPuzzleClick;
            }

            //On click functionality -- rotates the clicked pipe
            function onPuzzleClick(e) {

                NormalOrUndoClick = 1;

                if (e.layerX || e.layerX === 0) {
                    _mouse.x = e.layerX - _canvas.offsetLeft;
                    _mouse.y = e.layerY - _canvas.offsetTop;
                }
                else if (e.offsetX || e.offsetX === 0) {
                    _mouse.x = e.offsetX - _canvas.offsetLeft;
                    _mouse.y = e.offsetY - _canvas.offsetTop;
                }
                _currentPipe = checkpipeClicked();

                //HistoryList(_currentPipe);

                if (_currentPipe !== null) {

                 _stage.clearRect(_currentPipe.xPos, _currentPipe.yPos, _pipeWidth, _pipeHeight);

                    // save the unrotated context of the canvas so we can restore it later
                    // the alternative is to untranslate & unrotate after drawing
                    _stage.save();

                    // move to the center of the canvas
                    _stage.translate(_currentPipe.xPos + (_pipeWidth / 2), _currentPipe.yPos + (_pipeHeight / 2));

                    _stage.globalAlpha = 1; //Set transparency 


                    //Save action to arrays for Undo/redo]
                    /*
                    historyListXpos.push(_currentPipe.xPos);
                    historyListYpos.push(_currentPipe.yPos);
                    historyListOrientation.push(_currentPipe.orientation);
                    historyListPipeType.push(_currentPipe.image);*/




                    updateOrientation(_currentPipe);
                    //adds it to the stack 
                    PipesStack.push(_currentPipe);
                    document.getElementById("num_of_things_in_the_stack").innerHTML = 'num_of_things_in_the_stack: ' + PipesStack.length;

                    _stage.globalAlpha = 1; //Set transparency 
					
					/*
					//Save action to arrays for Undo/redo
					historyListXpos.push(_currentPipe.xPos);
					historyListYpos.push(_currentPipe.yPos);
					historyListOrientation.push(_currentPipe.orientation);
					historyListPipeType.push(_currentPipe.image);
                                         */
					
					
                    //draw(_currentPipe);			
					
                    //updateOrientation(_currentPipe);
		

                    // rotate the canvas to the specified degrees
                    _stage.rotate(_currentPipe.orientation * Math.PI / 180);

                    // draw the image
                    // since the context is rotated, the image will be rotated also.
                    _stage.drawImage(_currentPipe.image, -_img_straight.width / 2, -_img_straight.width / 2);

                    // we’re done with the rotating so restore the unrotated context
                    _stage.restore();

                    //add the border again after restoring the translate and rotate states.
                    _stage.strokeRect(_currentPipe.xPos, _currentPipe.yPos, _pipeWidth, _pipeHeight);
                  // _stage.strokeRect(_currentPipe.xPos, _currentPipe.yPos, _pipeWidth, _pipeHeight);


                    //reset the REDO arrays 
                    REDOhistoryListXpos = [];
                    REDOhistoryListYpos = [];
                    REDOhistoryListOrientation = [];
                    REDOhistoryListPipeType = [];

                    
                    //checkWin();
                    //sresetPuzzleAndCheckWin();
                    //document.onmousemove = updatePuzzle;
                    //document.onmouseup = pipeDropped;
                }

                /*
                if (historyListXpos[0] == null)
                    undoButton.disabled = true;
                else {
                    undoButton.disabled = false;
                }
                if (0 < RedoStack.length) {
                    redobutton.disabled = false;
                }
                */
                //redoButton.disabled = false;


            }

            function undo() {
                var last_pipe = PipesStack.pop();
                RedoStack.push(last_pipe);
                document.getElementById("last_element").innerHTML = 'Last Elements XPosition: ' + last_pipe.xPos;
                 _stage.clearRect(last_pipe.xPos, last_pipe.yPos, _pipeWidth, _pipeHeight);

                    // save the unrotated context of the canvas so we can restore it later
                    // the alternative is to untranslate & unrotate after drawing
                    _stage.save();

                    // move to the center of the canvas
                    _stage.translate(last_pipe.xPos + (_pipeWidth / 2), last_pipe.yPos + (_pipeHeight / 2));

                    _stage.globalAlpha = 1; //Set transparency 

                    updateOrientationForUndo(last_pipe);

                    // rotate the canvas to the specified degrees
                    _stage.rotate(last_pipe.orientation * Math.PI / 180);

                    // draw the image
                    // since the context is rotated, the image will be rotated also.
                    _stage.drawImage(last_pipe.image, -_img_straight.width / 2, -_img_straight.width / 2);

                    // we’re done with the rotating so restore the unrotated context
                    _stage.restore();

                    //add the border again after restoring the translate and rotate states.
                    _stage.strokeRect(last_pipe.xPos, last_pipe.yPos, _pipeWidth, _pipeHeight);

                /*
                NormalOrUndoClick = 0;
                _stage.clearRect(historyListXpos[historyListXpos.length - 1], historyListYpos[historyListXpos.length - 1], _pipeWidth, _pipeHeight);

                // save the unrotated context of the canvas so we can restore it later
                // the alternative is to untranslate & unrotate after drawing
                _stage.save();

                // move to the center of the canvas
                _stage.translate(historyListXpos[historyListXpos.length - 1] + (_pipeWidth / 2), historyListYpos[historyListYpos.length - 1] + (_pipeHeight / 2));

                _stage.globalAlpha = 1; //Set transparency 

                updateOrientation(historyListOrientation[historyListOrientation.length - 1]);

                //Check if pipe is connected to another pipe
                //checkConnection(_currentPipe);

                // rotate the canvas to the specified degrees
                _stage.rotate(historyListOrientation[historyListOrientation.length - 1] * Math.PI / 180);

                // draw the image
                // since the context is rotated, the image will be rotated also.
                _stage.drawImage(historyListPipeType[historyListPipeType.length - 1], -_img_straight.width / 2, -_img_straight.width / 2);

                // we’re done with the rotating so restore the unrotated context
                _stage.restore();

                //add the border again after restoring the translate and rotate states.
                _stage.strokeRect(historyListXpos[historyListXpos.length - 1], historyListYpos[historyListYpos.length - 1], _pipeWidth, _pipeHeight);




                //Remove action and send it to REDO stack  
                REDOhistoryListXpos.push(historyListXpos.pop());
                REDOhistoryListYpos.push(historyListYpos.pop());
                REDOhistoryListOrientation.push(historyListOrientation.pop());
                REDOhistoryListPipeType.push(historyListPipeType.pop());


                //Remove action and send to REDO
                REDOhistoryListOpenLeft.push(historyListOpenLeft.pop());
                REDOhistoryListOpenUp.push(historyListOpenUp.pop());
                REDOhistoryListOpenRight.push(historyListOpenRight.pop());
                REDOhistoryListOpenDown.push(historyListOpenDown.pop());

                if (REDOhistoryListXpos[0] == null)
                    redoButton.disabled = true;
                else {
                    redoButton.disabled = false;
                }


*/

                console.log("Undo Button Working.");
            }

            function redo() {
                var last_pipe_in_redo = RedoStack.pop();
                PipesStack.push(last_pipe_in_redo);
                
                _stage.clearRect(last_pipe_in_redo.xPos, last_pipe_in_redo.yPos, _pipeWidth, _pipeHeight);

                    // save the unrotated context of the canvas so we can restore it later
                    // the alternative is to untranslate & unrotate after drawing
                    _stage.save();

                    // move to the center of the canvas
                    _stage.translate(last_pipe_in_redo.xPos + (_pipeWidth / 2), last_pipe_in_redo.yPos + (_pipeHeight / 2));

                    _stage.globalAlpha = 1; //Set transparency 

                    updateOrientation(last_pipe_in_redo);
                    //adds it to the stack 
                    PipesStack.push(last_pipe_in_redo);
                    document.getElementById("num_of_things_in_the_stack").innerHTML = 'num_of_things_in_the_stack: ' + PipesStack.length;

                    //Check if pipe is connected to another pipe
                    //checkConnection(_currentPipe);

                    // rotate the canvas to the specified degrees
                    _stage.rotate(last_pipe_in_redo.orientation * Math.PI / 180);

                    // draw the image
                    // since the context is rotated, the image will be rotated also.
                    _stage.drawImage(last_pipe_in_redo.image, -_img_straight.width / 2, -_img_straight.width / 2);

                    // we’re done with the rotating so restore the unrotated context
                    _stage.restore();

                    //add the border again after restoring the translate and rotate states.
                    _stage.strokeRect(last_pipe_in_redo.xPos, last_pipe_in_redo.yPos, _pipeWidth, _pipeHeight);

                
                /*
                _stage.clearRect(REDOhistoryListXpos[REDOhistoryListXpos.length - 1], REDOhistoryListYpos[REDOhistoryListYpos.length - 1], _pipeWidth, _pipeHeight);

                // save the unrotated context of the canvas so we can restore it later
                // the alternative is to untranslate & unrotate after drawing
                _stage.save();

                // move to the center of the canvas
                _stage.translate(REDOhistoryListXpos[REDOhistoryListXpos.length - 1] + (_pipeWidth / 2), REDOhistoryListYpos[REDOhistoryListYpos.length - 1] + (_pipeHeight / 2));

                _stage.globalAlpha = 1; //Set transparency 

                updateOrientation(REDOhistoryListOrientation[REDOhistoryListOrientation.length - 1]);

                //Check if pipe is connected to another pipe
                //checkConnection(_currentPipe);

                // rotate the canvas to the specified degrees
                _stage.rotate(REDOhistoryListOrientation[REDOhistoryListOrientation.length - 1] * Math.PI / 180);

                // draw the image
                // since the context is rotated, the image will be rotated also.
                _stage.drawImage(REDOhistoryListPipeType[REDOhistoryListPipeType.length - 1], -_img_straight.width / 2, -_img_straight.width / 2);

                // we�are done with the rotating so restore the unrotated context
                _stage.restore();

                //add the border again after restoring the translate and rotate states.
                _stage.strokeRect(REDOhistoryListXpos[REDOhistoryListXpos.length - 1], REDOhistoryListYpos[REDOhistoryListYpos.length - 1], _pipeWidth, _pipeHeight);

                //Remove action and send it to UNDO stack  
                historyListXpos.push(REDOhistoryListXpos.pop());
                historyListYpos.push(REDOhistoryListYpos.pop());
                historyListOrientation.push(REDOhistoryListOrientation.pop());
                historyListPipeType.push(REDOhistoryListPipeType.pop());

                console.log("Redo Button Working." + REDOhistoryListYpos[0] + historyListOrientation[0]);
           */
             }

            //Check to see if the user has clicked on a pipe
            //If they have, return the pipe object
            function checkpipeClicked() {
                var i;
                var pipe;
                for (i = 0; i < _pipe_grid.length; i++) {
                    pipe = _pipe_grid[i];
                    if (_mouse.x < pipe.xPos || _mouse.x > (pipe.xPos + _pipeWidth) || _mouse.y < pipe.yPos || _mouse.y > (pipe.yPos + _pipeHeight)) {
                        //pipe NOT HIT
                    }
                    else {
                        return pipe;
                    }
                }
                return null;
            }

            function gameOver() {
                document.onmousedown = null;
                document.onmousemove = null;
                document.onmouseup = null;
                initPuzzle();
            }




            function updateOrientation(currentPipe) {
                
                currentPipe.orientation += 90;

                if (currentPipe.orientation === 360) {
                    currentPipe.orientation = 0;
                }

                if (currentPipe.image === _img_straight) {
                    if (currentPipe.orientation === 0 || currentPipe.orientation === 180) {
                        currentPipe.openLeft = true;
                        currentPipe.openUp = false;
                        currentPipe.openRight = true;
                        currentPipe.openDown = false;
                    }
                    else {
                        currentPipe.openLeft = false;
                        currentPipe.openUp = true;
                        currentPipe.openRight = false;
                        currentPipe.openDown = true;
                    }
                }

                if (currentPipe.image === _img_bent) {
                    if (currentPipe.orientation === 0) {
                        currentPipe.openLeft = true;
                        currentPipe.openUp = false;
                        currentPipe.openRight = false;
                        currentPipe.openDown = true;
                    }
                    else if (currentPipe.orientation === 90) {
                        currentPipe.openLeft = true;
                        currentPipe.openUp = true;
                        currentPipe.openRight = false;
                        currentPipe.openDown = false;
                    }
                    else if (currentPipe.orientation === 180) {
                        currentPipe.openLeft = false;
                        currentPipe.openUp = true;
                        currentPipe.openRight = true;
                        currentPipe.openDown = false;
                    }
                    else if (currentPipe.orientation === 270) {
                        currentPipe.openLeft = false;
                        currentPipe.openUp = false;
                        currentPipe.openRight = true;
                        currentPipe.openDown = true;
                    }




                }

                document.getElementById("test1").innerHTML = 'left= ' + currentPipe.openLeft;
                document.getElementById("test2").innerHTML = 'up= ' + currentPipe.openUp;
                document.getElementById("test3").innerHTML = 'right= ' + currentPipe.openRight;
                document.getElementById("test4").innerHTML = 'down= ' + currentPipe.openDown;

                /*
                if (NormalOrUndoClick = 1) {
                    //Save logic
                    historyListOpenLeft.push(currentPipe.openLeft);
                    historyListOpenUp.push(currentPipe.openUp);
                    historyListOpenRight.push(currentPipe.openRight);
                    historyListOpenDown.push(currentPipe.openDown);

                }
                
               
                document.getElementById("testUndo").innerHTML = 'Orientation = ' + historyListOrientation + '<br />' + ' xPos ='
                        + historyListXpos + '<br />' + ' yPos = ' + historyListYpos + '<br />' + historyListOpenUp + '<br />' + 'REDOOrientation = ' + REDOhistoryListOrientation + '<br />' + ' REDOxPos ='
                        + REDOhistoryListXpos + '<br />' + ' REDOyPos = ' + REDOhistoryListYpos + '<br />' + REDOhistoryListOpenUp;
                ;
            */

            }

            function updateOrientationForUndo(currentPipe) {
                
                currentPipe.orientation -= 90;

                if (currentPipe.orientation === 360) {
                    currentPipe.orientation = 0;
                }

                if (currentPipe.image === _img_straight) {
                    if (currentPipe.orientation === 0 || currentPipe.orientation === 180) {
                        currentPipe.openLeft = true;
                        currentPipe.openUp = false;
                        currentPipe.openRight = true;
                        currentPipe.openDown = false;
                    }
                    else {
                        currentPipe.openLeft = false;
                        currentPipe.openUp = true;
                        currentPipe.openRight = false;
                        currentPipe.openDown = true;
                    }
                }

                if (currentPipe.image === _img_bent) {
                    if (currentPipe.orientation === 0) {
                        currentPipe.openLeft = true;
                        currentPipe.openUp = false;
                        currentPipe.openRight = false;
                        currentPipe.openDown = true;
                    }
                    else if (currentPipe.orientation === 90) {
                        currentPipe.openLeft = true;
                        currentPipe.openUp = true;
                        currentPipe.openRight = false;
                        currentPipe.openDown = false;
                    }
                    else if (currentPipe.orientation === 180) {
                        currentPipe.openLeft = false;
                        currentPipe.openUp = true;
                        currentPipe.openRight = true;
                        currentPipe.openDown = false;
                    }
                    else if (currentPipe.orientation === 270) {
                        currentPipe.openLeft = false;
                        currentPipe.openUp = false;
                        currentPipe.openRight = true;
                        currentPipe.openDown = true;
                    }




                }

                document.getElementById("test1").innerHTML = 'left= ' + currentPipe.openLeft;
                document.getElementById("test2").innerHTML = 'up= ' + currentPipe.openUp;
                document.getElementById("test3").innerHTML = 'right= ' + currentPipe.openRight;
                document.getElementById("test4").innerHTML = 'down= ' + currentPipe.openDown;

                /*
                if (NormalOrUndoClick = 1) {
                    //Save logic
                    historyListOpenLeft.push(currentPipe.openLeft);
                    historyListOpenUp.push(currentPipe.openUp);
                    historyListOpenRight.push(currentPipe.openRight);
                    historyListOpenDown.push(currentPipe.openDown);

                }
                

                document.getElementById("testUndo").innerHTML = 'Orientation = ' + historyListOrientation + '<br />' + ' xPos ='
                        + historyListXpos + '<br />' + ' yPos = ' + historyListYpos + '<br />' + historyListOpenUp + '<br />' + 'REDOOrientation = ' + REDOhistoryListOrientation + '<br />' + ' REDOxPos ='
                        + REDOhistoryListXpos + '<br />' + ' REDOyPos = ' + REDOhistoryListYpos + '<br />' + REDOhistoryListOpenUp;
                ;
                */

            }


            function checkConnection(_currentpipe_index) {
                var pipe = _pipe_grid[_currentpipe_index];

                if (pipe.image === _img_straight)
                {
                    document.getElementById("demo1").innerHTML = "hello" + _currentpipe_index;
                    if (_currentpipe_index !== 35 && _currentpipe_index !== 0 && _currentpipe_index !== 35 && pipe.openLeft === true && pipe.openRight === true && _pipe_grid[_currentpipe_index + 1].openLeft === true && (_previouspipe_index - _currentpipe_index === -1) && (_currentpipe_index + 1 >= 0 && _currentpipe_index + 1 < 36)) {
                        _currentpipe_index += 1;
                        _previouspipe_index = _currentpipe_index;
                        _previouspipe_index -= 1;
                        checkConnection(_currentpipe_index);
                    }
                    if (_currentpipe_index !== 35 && _currentpipe_index === 0 && pipe.openLeft === true && pipe.openRight === true) {
                        _currentpipe_index += 1;
                        _previouspipe_index = _currentpipe_index;
                        _previouspipe_index -= 1;
                        checkConnection(_currentpipe_index);
                    }
                    if (_currentpipe_index !== 35 && _currentpipe_index !== 0 && pipe.openLeft === true && pipe.openRight === true && _pipe_grid[_currentpipe_index - 1].openRight === true && (_previouspipe_index - _currentpipe_index === 1) && (_currentpipe_index - 1 >= 0 && _currentpipe_index - 1 < 36)) {
                        _currentpipe_index -= 1;
                        _previouspipe_index = _currentpipe_index;
                        _previouspipe_index += 1;
                        checkConnection(_currentpipe_index);
                    }
                    if (_currentpipe_index !== 35 && pipe.openUp === true && pipe.openDown === true && _pipe_grid[_currentpipe_index + 6].openUp === true && (_previouspipe_index - _currentpipe_index === -6) && (_currentpipe_index + 6 >= 0 && _currentpipe_index + 6 < 36)) {
                        _currentpipe_index += 6;
                        _previouspipe_index = _currentpipe_index;
                        _previouspipe_index -= 6;
                        checkConnection(_currentpipe_index);
                    }
                    if (_currentpipe_index !== 35 && pipe.openUp === true && pipe.openDown === true && _pipe_grid[_currentpipe_index - 6].openDown === true && (_previouspipe_index - _currentpipe_index === 6) && (_currentpipe_index - 6 >= 0 && _currentpipe_index - 6 < 36)) {
                        _currentpipe_index -= 6;
                        _previouspipe_index = _currentpipe_index;
                        _previouspipe_index += 6;
                        checkConnection(_currentpipe_index);
                    }
                }
                else if (pipe.image === _img_bent)
                {
                    document.getElementById("demo2").innerHTML = _currentpipe_index;

                    if (_currentpipe_index !== 35 && _currentpipe_index === 0 && pipe.openLeft === true && pipe.openDown === true && _pipe_grid[_currentpipe_index + 6].openUp === true && (_currentpipe_index + 6 >= 0 && _currentpipe_index + 6 < 36)) {
                        _currentpipe_index += 6;
                        _previouspipe_index = _currentpipe_index;
                        _previouspipe_index -= 6;
                        checkConnection(_currentpipe_index);
                    }
                    if (_currentpipe_index !== 35 && _currentpipe_index !== 0 && pipe.openLeft === true && pipe.openDown === true && _pipe_grid[_currentpipe_index + 6].openUp === true && (_previouspipe_index - _currentpipe_index === -1) && (_currentpipe_index + 6 >= 0 && _currentpipe_index + 6 < 36)) {
                        _currentpipe_index += 6;
                        _previouspipe_index = _currentpipe_index;
                        _previouspipe_index -= 6;
                        checkConnection(_currentpipe_index);
                    }
                    if (_currentpipe_index !== 35 && _currentpipe_index !== 0 && pipe.openLeft === true && pipe.openDown === true && _pipe_grid[_currentpipe_index - 1].openRight === true && (_previouspipe_index - _currentpipe_index === 6) && (_currentpipe_index - 1 >= 0 && _currentpipe_index - 1 < 36)) {
                        _currentpipe_index -= 1;
                        _previouspipe_index = _currentpipe_index;
                        _previouspipe_index += 1;
                        checkConnection(_currentpipe_index);
                    }
                    if (_currentpipe_index !== 35 && pipe.openLeft === true && pipe.openUp === true && _pipe_grid[_currentpipe_index - 6].openDown === true && (_previouspipe_index - _currentpipe_index === -1) && (_currentpipe_index - 6 >= 0 && _currentpipe_index - 6 < 36)) {
                        _currentpipe_index -= 6;
                        _previouspipe_index = _currentpipe_index;
                        _previouspipe_index += 6;
                        checkConnection(_currentpipe_index);
                    }
                    if (_currentpipe_index !== 35 && pipe.openLeft === true && pipe.openUp === true && _pipe_grid[_currentpipe_index - 1].openRight === true && (_previouspipe_index - _currentpipe_index === -6) && (_currentpipe_index - 1 >= 0 && _currentpipe_index - 1 < 36)) {
                        _currentpipe_index -= 1;
                        _previouspipe_index = _currentpipe_index;
                        _previouspipe_index += 1;
                        checkConnection(_currentpipe_index);
                    }
                    if (_currentpipe_index !== 35 && pipe.openRight === true && pipe.openDown === true && _pipe_grid[_currentpipe_index + 6].openUp === true && (_previouspipe_index - _currentpipe_index === 1) && (_currentpipe_index + 6 >= 0 && _currentpipe_index + 6 < 36)) {
                        _currentpipe_index += 6;
                        _previouspipe_index = _currentpipe_index;
                        _previouspipe_index -= 6;
                        checkConnection(_currentpipe_index);
                    }
                    if (_currentpipe_index !== 35 && pipe.openRight === true && pipe.openDown === true && _pipe_grid[_currentpipe_index + 6].openUp === true && (_previouspipe_index - _currentpipe_index === 6) && (_currentpipe_index + 1 >= 0 && _currentpipe_index + 1 < 36)) {
                        _currentpipe_index += 1;
                        _previouspipe_index = _currentpipe_index;
                        _previouspipe_index -= 1;
                        checkConnection(_currentpipe_index);
                    }
                    if (_currentpipe_index !== 35 && pipe.openRight === true && pipe.openUp === true && _pipe_grid[_currentpipe_index + 1].openLeft === true && (_previouspipe_index - _currentpipe_index === -6) && (_currentpipe_index + 1 >= 0 && _currentpipe_index + 1 < 36)) {
                        _currentpipe_index += 1;
                        _previouspipe_index = _currentpipe_index;
                        _previouspipe_index -= 1;
                        checkConnection(_currentpipe_index);
                    }
                    if (_currentpipe_index !== 35 && pipe.openRight === true && pipe.openUp === true && _pipe_grid[_currentpipe_index + 1].openDown === true && (_previouspipe_index - _currentpipe_index === -1) && (_currentpipe_index + 1 >= 0 && _currentpipe_index + 1 < 36)) {
                        _currentpipe_index -= 6;
                        _previouspipe_index = _currentpipe_index;
                        _previouspipe_index += 6;
                        checkConnection(_currentpipe_index);
                    }
                }
                if (_currentpipe_index === 35 && _pipe_grid[35].openRight === true) {
                    document.getElementById("demo3").innerHTML = 'YOU WON'
                            ;

                } 

            }
            function checkWin() {
                if (_pipe_grid[0].openLeft === true) {
                    checkConnection(0); 
                }
            }
            var looper;
            var degrees = 0;
            
            function rotateAnimation(el,speed){
             /* 
                var elem = el;
                if(navigator.userAgent.match("Chrome")){
                        elem.style.WebkitTransform = "rotate("+degrees+ "deg)";
                            } else if (navigator.userAgent.match("Firefox")) {
                                elem.style.MozTransform = "rotate(" + degrees + "deg)";
                            } else if (navigator.userAgent.match("MSIE")) {
                                elem.style.msTransform = "rotate(" + degrees + "deg)";
                            } else if (navigator.userAgent.match("Opera")) {
                                elem.style.OTransform = "rotate(" + degrees + "deg)";
                            } else {
                                elem.style.transform = "rotate(" + degrees + "deg)";
                            }
                            looper = setTimeout('rotateAnimation(\'' + el + '\',' + speed + ')', speed);
                            degrees++;
                            if (degrees > 359) {
                                degrees = 1;
                            }
                         //   document.getElementById("status").innerHTML = "rotate(" + degrees + "deg)";
        */        
        }

            //Get the pipe grid array reference
            //            var index = 0;
            //            for(i = 0;i < _pipe_grid.length;i++){
            //                if (currentPipe === _pipe_grid[i]) {
            //                    index = i;
            //                    break;
            //                }
            //            }
            //            
            //            if (_pipe_grid[index].openLeft === true && _pipe_grid[index].openRight === true) {
            //                
            //                //If this pipe is the start pipe
            //                if (_pipe_grid[index] === _pipe_grid[0]) {
            //                    currentPipe.connectedToA = true; 
            //                }
            //                
            //                //If this pipe is the end pipe
            //                else if (_pipe_grid[index] === _pipe_grid[_pipe_grid.length-1]) {
            //                    currentPipe.connectedToB = true; 
            //                }
            //                
            //                //If a pipe exists to the left of this pipe:
            //                else if(typeof _pipe_grid[index-1] !== 'undefined'){
            //                    //Check if that pipe is connected to this pipe
            //                    if (_pipe_grid[index-1].openRight === true) {
            //                        //set the current pipes connectedToX values to the same as
            //                        //the pipe it's connected to.
            //                        currentPipe.connectedToA === _pipe_grid[index-1].connectedToA;
            //                        currentPipe.connectedToB === _pipe_grid[index-1].connectedToB;
            //                    }
            //                }
            //                
            //                //If this is not the start pipe
            //                //or the end pipe
            //                //or connected to a pipe to the left
            //                else {
            //                    currentPipe.connectedToA = false; 
            //                    currentPipe.connectedToB = false; 
            //                }   
            //            }
            //            if (_pipe_grid[index].openUp === true) {
            //                
            //            }
            //            if (_pipe_grid[index].openRight === true) {
            //                
            //            }
            //            if (_pipe_grid[index].openDown === true) {
            //                
            //            }

            //If connected to A and B == true then it's game over.

            //DEBUGGING:
            //document.getElementById("debugConnections").innerHTML = 'connectedA: ' + currentPipe.connectedToA + '        connectedB: ' + currentPipe.connectedToB;
            // }

//            function checkIfWin() {
//                for (i = 0; i < _pipe_grid.length; i++) {
//
//                    if (_pipe_grid[0].openLeft === true) {
//
//                        //How the hell can we check if it's game over O.o
//                        document.getElementById("demo").innerHTML = 'pipe zero is connected to the left';
//
//                        //Find the pipe it's connected to:
//                        //if 
//
//                    }
//                    else {
//                        document.getElementById("demo").innerHTML = 'pipe zero is not connected';
//                    }
//                }
//            }


	
        
        //Crazy timeout function for animation - 
        (function() {
            var lastTime = 0;
            var vendors = ['ms', 'moz', 'webkit', 'o'];
            for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
                window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
                window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame'] 
                                           || window[vendors[x]+'CancelRequestAnimationFrame'];
            }

            if (!window.requestAnimationFrame)
                window.requestAnimationFrame = function(callback, element) {
                    var currTime = new Date().getTime();
                    var timeToCall = Math.max(0, 16 - (currTime - lastTime));
                    var id = window.setTimeout(function() { callback(currTime + timeToCall); }, 
                      timeToCall);
                    lastTime = currTime + timeToCall;
                    return id;
                };

            if (!window.cancelAnimationFrame)
                window.cancelAnimationFrame = function(id) {
                    clearTimeout(id);
                };
        }());
        
        function draw(_currentPipe) {
            setTimeout(function() {
                window.requestAnimationFrame(draw);

                degrees = _currentPipe.orientation;
                degrees++;
                if(degrees > 359){
                        degrees = 1;
                }
                
                
                /*
                if (pos > xMax || pos < xMin) {
                    dir *= -1;
                }

                pos += (dir * speed);
                */
                
                
                //ball.css('top', pos + 'px');
                _stage.clearRect(_currentPipe.xPos, _currentPipe.yPos, _pipeWidth, _pipeHeight);
                // save the unrotated context of the canvas so we can restore it later
                // the alternative is to untranslate & unrotate after drawing
                _stage.save();
                // move to the center of the canvas
                _stage.translate(pos + (_pipeWidth / 2), _currentPipe.yPos + (_pipeHeight / 2));
                _stage.globalAlpha = 0.5; //Set transparency 							
                //updateOrientation(_currentPipe);		                    
                //Check if pipe is connected to another pipe
                //checkConnection(_currentPipe);
                // rotate the canvas to the specified degrees
                _stage.rotate(degrees * Math.PI / 180);
                // draw the image
                // since the context is rotated, the image will be rotated also.
                _stage.drawImage(_currentPipe.image, -_img_straight.width / 2, -_img_straight.width / 2);

                //we’re done with the rotating so restore the unrotated context
                _stage.restore();
                    
            }, interval);
        }
					
        </script>
    </head>

    <body onload="init();">
        <canvas id="canvas" ></canvas>
        <button onclick="undo()" id='undoButton'>Undo</button>
        <!--- <button onclick="undo()" id='undoButton' disabled>Undo</button> --->
        <button onclick="redo()" id='redoButton' >Redo</button>
       
        <a onmouseup="undo();" href="javascript:undo();">Undo</a>
        <a onmouseup="redo();" href="javascript:undo();">Redo</a>
        <a onmouseup="checkWin();" href="javascript:undo();">Click Me</a>
        
        
        <p id="testUndo"></p>
        <p id="ButtonWorks"></p>
        <p id="demo"></p>
        <p id="test1"></p>
        <p id="test2"></p>
        <p id="test3"></p>
        <p id="test4"></p>
        <button onclick="checkWin()">Click me</button>
        <p id="demo1"></p>
        <p id="demo2"></p>
        <p id="demo3"></p>

        <p id="debugConnections"></p>

        <p id="demo4"></p>
        <p id="num_of_things_in_the_stack"></p>
    <p id="last_element"></p>

    </body>

</html>
