<!DOCTYPE html>
<html>
<head>

    <title>Peach Pipe Puzzle</title>
    <script>
		
        // Color for when hovering over a square (NOT NECESSERY)
        const PUZZLE_HOVER_TINT = '#009900';

        // Sets the number of rows and columns
        var _pipegrid_rows = 6;
        var _pipegrid_cols = 6;
        
        var _stage;
        var _canvas;
		
	var _test_degrees = 90;
        
        
        var _img;
        var _puzzleWidth;
        var _puzzleHeight;
        
        //Need to remove these two variables, as they're now contained in the 
        //pipe object.
        var _pipeWidth;
        var _pipeHeight;

        var _currentPipe;
        var _currentDropPipe;  

        var _mouse;
        
        //Pipe class
        function Pipe() {
        this.orientation = 0;
        this.xPos = 0;
        this.yPos = 0;
        this.width = 0;
        this.height = 0;
        this.openLeft = false;
        this.openUp = false;
        this.openRight = false;
        this.openDown = false;
        this.image = null;
        }
        
        //array to store the pipe struct in
        var _pipe_grid = [];

	// Set the straight and bent pipe images up, so they can be referenced
        // by the pipe objects 
        function init(){
            _img_splash = new Image();
            _img_splash.addEventListener('load',onImage,false);
            _img_splash.src = "SplashScreen.png";
            
            _img_straight = new Image();
            _img_straight.addEventListener('load',onImage,false);
            _img_straight.src = "straightpipe-01.png";
            
            _img_bent = new Image();
            _img_bent.addEventListener('load',onImage,false);
            _img_bent.src = "bentpipe-01.png";
        }
        
        // Set the width and height for each pipe, dependant on the number of pipes
        function onImage(e){
            _pipeWidth = Math.floor(_img_straight.width);
            _pipeHeight = Math.floor(_img_straight.height);
            _puzzleWidth = _pipeWidth * _pipegrid_cols;
            _puzzleHeight = _pipeHeight * _pipegrid_rows;
            setCanvas();
            initGrid();
        }
        
        // Set Canvas
        function setCanvas(){
            _canvas = document.getElementById('canvas');
            _stage = _canvas.getContext('2d');
            _canvas.width = _puzzleWidth;
            _canvas.height = _puzzleHeight;
            _canvas.style.border = "1px solid black";
        }
        
        // Init variables for the pipe puzzle (before the pipes are randomized)
        function initGrid(){
            //_pipe_grid = [];
            _mouse = {x:0,y:0};
            _currentpipe = null;
            _currentDroppipe = null;
            //Draw a start up image :)
            _stage.drawImage(_img_splash, 0, 0, _puzzleWidth, _puzzleHeight, 0, 100, _puzzleWidth, _puzzleHeight);
            createTitle("Double click to start game!!");
            document.onmousedown = buildGrid;
        }
        
        //Create a fillable rectangle, place text inside of it.
        function createTitle(msg){
            //Create a fillable rectangle, params: fillRect(x, y, width, height). 
            //Where x and y are the coordinates of the upper left corners position.
            _stage.fillStyle = "#000000";
            _stage.globalAlpha = .4;  
            _stage.fillRect(100,_puzzleHeight - 40,_puzzleWidth - 200,40);
            _stage.fillStyle = "#FFFFFF";
            _stage.globalAlpha = 1;
            
            //Place a message inside of the fillable rectangle. 
            _stage.textAlign = "center";
            _stage.textBaseline = "middle";
            _stage.font = "20px Arial";
            _stage.fillText(msg,_puzzleWidth / 2,_puzzleHeight - 20);
        }
        
        //Init an array of all of the pipe puzzle pipes. 
        function buildGrid(){
            var i;
            var xPosition = 0;
            var yPosition = 0;
            for(i = 0;i < _pipegrid_cols * _pipegrid_rows; i++){
                
                //Create a new pipe object
                var newPipe = new Pipe();
                newPipe.xPos = xPosition;
                newPipe.yPos = yPosition;
                newPipe.image = null;
                
                //Randomize between bent and straight pipes  
                if (Math.random() < 0.5) {
                    if (newPipe.image == null)
                    newPipe.image = _img_straight;
                }
                else {
                    if (newPipe.image == null)
                    newPipe.image = _img_bent;
                } 
                
                //Push pipe structure into the pipe grid array!
                _pipe_grid.push(newPipe); 
  
                //Update the position ready for the placement of next pipe:
                xPosition += _pipeWidth;
                if(xPosition >= _puzzleWidth){
                    xPosition = 0;
                    yPosition += _pipeHeight;
                }
            }
            //Set the mouse down command to call the ShufflePuzzle method
            document.onmousedown = drawPuzzle;
        }
        
        //Shuffle the array, clear the stage, replace the peices. 
        function drawPuzzle(){
            //_pipe_grid = shuffleArray(_pipe_grid);
            _stage.clearRect(0,0,_puzzleWidth,_puzzleHeight);
            var i;
            var pipe;
            for(i = 0;i < _pipe_grid.length;i++){
                pipe = _pipe_grid[i];
                
                _stage.drawImage(pipe.image, pipe.xPos, pipe.yPos, _pipeWidth, _pipeHeight);
                _stage.strokeRect(pipe.xPos, pipe.yPos, _pipeWidth, _pipeHeight);
            }
            //Set the mouse down command to call the onPuzzleClick method
            document.onmousedown = onPuzzleClick;
        }
        
        //On click functionality -- 
        //Need to edit this to rotate pipes instead of moving them
        function onPuzzleClick(e){
            if(e.layerX || e.layerX == 0){
                _mouse.x = e.layerX - _canvas.offsetLeft;
                _mouse.y = e.layerY - _canvas.offsetTop;
            }
            else if(e.offsetX || e.offsetX == 0){
                _mouse.x = e.offsetX - _canvas.offsetLeft;
                _mouse.y = e.offsetY - _canvas.offsetTop;
            }
            _currentPipe = checkpipeClicked();
            if(_currentPipe != null){
               
                _stage.clearRect(_currentPipe.xPos,_currentPipe.yPos,_pipeWidth,_pipeHeight);
                
                // save the unrotated context of the canvas so we can restore it later
                // the alternative is to untranslate & unrotate after drawing
                _stage.save();
                
                // move to the center of the canvas
                _stage.translate(_currentPipe.xPos + (_pipeWidth/2), _currentPipe.yPos + (_pipeHeight/2));
                
                _stage.globalAlpha = 1; //Set transparency 
                     
                // rotate the canvas to the specified degrees
                _stage.rotate(_test_degrees*Math.PI/180);
                
                _test_degrees += 90;
                
                // draw the image
                // since the context is rotated, the image will be rotated also.
                _stage.drawImage(_img_straight,-_img_straight.width/2,-_img_straight.width/2);
                
                // weâ€™re done with the rotating so restore the unrotated context
                _stage.restore();
                
                //add the border again after restoring the translate and rotate states.
                _stage.strokeRect(_currentPipe.xPos, _currentPipe.yPos, _pipeWidth, _pipeHeight);
                
                //sresetPuzzleAndCheckWin();
                //document.onmousemove = updatePuzzle;
                //document.onmouseup = pipeDropped;
            }
        }
        
        //Check to see if the user has clicked on a peice
        //If they have, return the peice
        function checkpipeClicked(){
            var i;
            var pipe;
            for(i = 0;i < _pipe_grid.length;i++){
                pipe = _pipe_grid[i];
                if(_mouse.x < pipe.xPos || _mouse.x > (pipe.xPos + _pipeWidth) || _mouse.y < pipe.yPos || _mouse.y > (pipe.yPos + _pipeHeight)){
                    //pipe NOT HIT
                }
                else{
                    return pipe;
                }
            }
            return null;
        }
        
        //Need to change this to rotate peices, and check if the puzzle is 
        //complete or not. (It's complete when a path has been created from
        //the start point to the finish point. 
        function updatePuzzle(e){
            _currentDroppipe = null;
            if(e.layerX || e.layerX == 0){
                _mouse.x = e.layerX - _canvas.offsetLeft;
                _mouse.y = e.layerY - _canvas.offsetTop;
            }
            else if(e.offsetX || e.offsetX == 0){
                _mouse.x = e.offsetX - _canvas.offsetLeft;
                _mouse.y = e.offsetY - _canvas.offsetTop;
            }
            _stage.clearRect(0,0,_puzzleWidth,_puzzleHeight);
            var i;
            var pipe;
            for(i = 0;i < _pipe_grid.length;i++){
                pipe = _pipe_grid[i];
                if(pipe == _currentPipe){
                    continue;
                }
                _stage.drawImage(_img, pipe.sx, pipe.sy, _pipeWidth, _pipeHeight, pipe.xPos, pipe.yPos, _pipeWidth, _pipeHeight);
                _stage.strokeRect(pipe.xPos, pipe.yPos, _pipeWidth,_pipeHeight);
                if(_currentDroppipe == null){
                    if(_mouse.x < pipe.xPos || _mouse.x > (pipe.xPos + _pipeWidth) || _mouse.y < pipe.yPos || _mouse.y > (pipe.yPos + _pipeHeight)){
                        //NOT OVER
                    }
                    else{
                        _currentDroppipe = pipe;
                        _stage.save();
                        _stage.globalAlpha = .4;
                        _stage.fillStyle = PUZZLE_HOVER_TINT;
                        _stage.fillRect(_currentDroppipe.xPos,_currentDroppipe.yPos,_pipeWidth, _pipeHeight);
                        _stage.restore();
                    }
                }
            }
            _stage.save();
            _stage.globalAlpha = .6;
            _stage.drawImage(_img, _currentPipe.sx, _currentPipe.sy, _pipeWidth, _pipeHeight, _mouse.x - (_pipeWidth / 2), _mouse.y - (_pipeHeight / 2), _pipeWidth, _pipeHeight);
            _stage.restore();
            _stage.strokeRect( _mouse.x - (_pipeWidth / 2), _mouse.y - (_pipeHeight / 2), _pipeWidth,_pipeHeight);
        }
        
        function pipeDropped(e){
            document.onmousemove = null;
            document.onmouseup = null;
            if(_currentDroppipe != null){
                var tmp = {xPos:_currentPipe.xPos,yPos:_currentPipe.yPos};
                _currentPipe.xPos = _currentDroppipe.xPos;
                _currentPipe.yPos = _currentDroppipe.yPos;
                _currentDroppipe.xPos = tmp.xPos;
                _currentDroppipe.yPos = tmp.yPos;
            }
            resetPuzzleAndCheckWin();
        }
        function resetPuzzleAndCheckWin(){
            _stage.clearRect(0,0,_puzzleWidth,_puzzleHeight);
            var gameWin = true;
            var i;
            var pipe;
            for(i = 0;i < _pipe_grid.length;i++){
                pipe = _pipe_grid[i];
                _stage.drawImage(_img, pipe.sx, pipe.sy, _pipeWidth, _pipeHeight, pipe.xPos, pipe.yPos, _pipeWidth, _pipeHeight);
                _stage.strokeRect(pipe.xPos, pipe.yPos, _pipeWidth,_pipeHeight);
                if(pipe.xPos != pipe.sx || pipe.yPos != pipe.sy){
                    gameWin = false;
                }
            }
            if(gameWin){
                setTimeout(gameOver,500);
            }
        }
        function gameOver(){
            document.onmousedown = null;
            document.onmousemove = null;
            document.onmouseup = null;
            initPuzzle();
        }
        
        //Function for shuffling the pipes.
        function shuffleArray(o){
            for(var j, x, i = o.length; i; j = parseInt(Math.random() * i), x = o[--i], o[i] = o[j], o[j] = x);
            return o;
        }

    </script>
</head>

<body onload="init();">
    <canvas id="canvas" ></canvas>
</body>

</html>